# Медиа запросы @media

[https://meyerweb.github.io/csstdg4figs/20-media-dependent-styles/index.html](https://meyerweb.github.io/csstdg4figs/20-media-dependent-styles/index.html)

[MDN](https://developer.mozilla.org/ru/docs/Web/CSS/Media_Queries/Using_media_queries)

Большая часть нашей CSS-работы заключается в размещении контента на экранах разных типов — будь то экраны которые находятся на столах в офисах или экраны мобильных устройств в наших руках.

Вариантов экранов большое множество. Они различаются по размеру, по цветопередаче, по принципу работы.

И кроме экранов, наши веб-документы или приложения могут выводиться и на других видах медиа — печатных или скрин-ридерах.

Понимая эти реалии CSS предоставляет набор инструментов для применения стилей к конкретным видам медиа, или медиа с конкретными возможностями.

## Определение стилей зависящих от медиа

Благодаря механизмам определенным в HTML и CSS, которые называются _media querries_, вы можете ограничивать любые наборы стилей к конкретным видам медиа. Эти механизмы позволяют определить виды медиа и параметры такие как размер дисплея или глубина цвета чтобы, при наличии которых будут применены ваши стили.

### Базовые медиа-запросы

Для стилей подключаемых в HTML вы можете указать ограничения медиа через атрибут `media`. Это работает как для элемента `link`, так и для `style`:

```html
<link rel="stylesheet" type="text/css" media="print"
    href="article-print.css">
<style type="text/css" media="speech">
    body {font-family: sans-serif;}
</style>
```

Значением атрибута может являться как единственное значение медиа, так и несколько значений разделенных запятыми.

```html
<link rel="stylesheet" type="text/css" media="screen, speech"
    href="visual.css">
```

В самих стилях также можно указать ограничение медиа в правилах `@import`:

```css
@import url(visual.css) screen;
@import url(outloud.css) speech;
@import url(article-print.css) print;
```

Помните, если вы не укажете тип медиа к файлу стилей, он будет применен ко всем видам медиа.

Если вы хотите применить один набор стилей к экранам, а другой к печати, вы должны добавить информацию о медиа к каждому из стилей:

```html
<link rel="stylesheet" type="text/css" media="screen"
    href="article-screen.css">
<link rel="stylesheet" type="text/css" media="print"
    href="article-print.css">
```

Если убрать медиа-атрибут у первой ссылки в предыдущем примере, стили найденные в файле `article-screen.css` будут применены ко всем видам медиа.

Также CSS позволяет определять блоки правил `@media` внутри блока или файла стилей:

```html
<style type="text/css">
body {background: white; color: black;}
@media screen {
    body {font-family: sans-serif;}
    h1 {margin-top: 1em;}
}
@media print {
    body {font-family: serif;}
    h1 {margin-top: 2em; border-bottom: 1px solid silver;}
}
</style>
```

Блоки `@media` могут быть любого размера и содержать любое количество правил CSS.

Перечень четырех самых популярных видов медиа:

`all`

Использовать стили для всех видов медиа

`print`

Когда печатаем документ для зрячих пользователей, а также когда показываем предварительный просмотр печати документа.

`screen`

Используется, когда документ показывается на экране, таком как десктопный монитор компьютера или наладонное устройство. Все браузеры работающие на таких устройствах, являются экранными пользовательскими агентами (screen-medium user agent).

`speech`

Используется в синтезаторах речи, экранных ридерах и других аудио-воспроизведениях документа

В HTML4 есть и другие виды медиа, но в настоящее время они считаются устаревшими и не должны использоваться.

Также возможно в будущем добавятся новые виды медиа. Так-что этот список не всегда будет таким ограниченным. Вариант нового медиа это устройства дополненной реальности.

В некоторых условиях возможно комбинирование типов медиа в списки разделенные запятыми, но не понятно зачем это нужно, когда на сейчас у нас есть сего три типа медиа.

Например, можно ограничить стили только выводом на экран и на печать:

```html
<link rel="stylesheet" type="text/css" media="screen, print"
    href="article.css">
```

```css
@import url(article.css) print, screen;

@media screen,print {
    /* styles go here */
}
```

### Комплексные медиа-запросы

В предыдущем разделе мы видели, что различные типы медиа могут быть объединены используя запятые в качестве разделителя. Но есть еще более продвинутые виды медиазапросов, которые позволяют адресовать не только вид медиа, но и конкретные особенности этих медиа, такие как размер дисплея или глубина цветопередачи.

Это дает очень много возможностей и здесь не достаточно одних запятых, чтобы реализовать их все. По этому CSS стал предлагать логические операторы для объединения нескольких медиазапросов.

[Булева алгебра](https://uk.wikipedia.org/wiki/%D0%91%D1%83%D0%BB%D0%B5%D0%B2%D0%B0_%D0%B0%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0)

Например вот два способа для подключения стилей в случае если мы выводим документ на печать в цвете:

```html
<link href="print-color.css" type="text/css"
    media="print and (color)" rel="stylesheet">
```

```css
@import url(print-color.css) print and (color);
```

Везде где можно указать тип медиа, можно сконструировать медиазапрос. Из этого следует, что предыдущие примеры можно переписать с использованием более чем одного медиазапроса, разделяя их запятыми:

```html
<link href="print-color.css" type="text/css"
   media="print and (color), screen and (color)" rel="stylesheet">
```

```css
@import url(print-color.css) print and (color), screen and (color);
```

В ситуациях где хотя бы один из запросов будет выполнен успешно, к документу будет применен указанный стиль.

Каждый медиа-дескриптор компонуется из типа медиа и одного или более проверки медиа-свойства, где проверки медиа-свойства заключаются в скобки.

Если тип медиа не проверяется, то стиль будет применен ко всем типам медиа, следующие примеры кода эквивалентны:

```css
@media all and (min-resolution: 96dpi) {…}
@media (min-resolution: 960dpi) {…}
```

Проще говоря медиа-дескриптор форматируется как пары свойство-значение в CSS, только заключенные в скобки. Но есть незначительные различия. Самое значимое это то, что некоторые свойства могут быть указаны без соответствующего значения. Например любой цветной тип медиа может быть указан используя `(color)`, в то же время цветной тип медиа именно в 16-битном цвете проверяется так `(color: 16)`. Как следствие, использование свойства без значения представляет собой проверку истинности для этого типа медиа: `(color)` означает «является медиа цветным вообще?».

Несколько дескрипторов могут быть объединены при помощи логических ключевых слов. По факту их всего два:

`and` — связывает вместе одно или несколько медиа-свойств таким образом, чтобы все они были истинными, для того чтобы запрос выполнился с истинным значением. Все условия должны быть удовлетворены. Это логическое умножение.

```css
@media (color) and (orientation: landscape) and (min-device-width: 800px) {...}
```

Все эти запросы должны быть истинными чтобы блок стилей был применен.

`not` — отрицание всего запроса, так что если все из условий истинны, тогда стиль не будет применен. Например:

```css
@media not (color) and (orientation: landscape) and (min-device-width: 800px) {...}
```

Означает что если все три условия удовлетворены, то блок стилей НЕ будет применен, так как мы отрицаем истинность этих условий. Но если хотя бы одно из условий будет ложно, мы будем отрицать ложь и медиа-запрос станет истинным, стили будут применены.

Ключевое слово `not` может быть использовано только в начале медиа-запроса. В настоящее время такая запись `(color) and not (min-device-width: 800px)` не соответствует стандартам. В таких случаях запрос будет проигнорирован. Если браузер слишком старый и не поддерживает медиа-запросы

[https://meyerweb.github.io/csstdg4figs/20-media-dependent-styles/mediaqueries-logical-operators.html](https://meyerweb.github.io/csstdg4figs/20-media-dependent-styles/mediaqueries-logical-operators.html)

В медиа-запросах нет ключевого слова `or` для логического ИЛИ, для этого используется разделение запятыми.

`only` — используется для обеспечения обратной совместимости. Для браузеров которые не понимают медиа-запросы и пропускают их целиком. Браузеры которые понимают медиа-запросы игнорируют это ключевое слово и просто выполняют медиа-запрос, старые браузеры пропускают целиком.

## Медиа-дескрипторы

`width, min-width, max-width: <length>`
`height, min-height, max-height: <length>`

[MDN](https://developer.mozilla.org/ru/docs/Web/CSS/@media) — полный список медиа-дескрипторов

# @supports Feature Queries

В 2015 и 2016 годах, CSS получил возможность применять блоки стилей, когда конкретные комбинации свойства и значения поддерживаются пользовательским агентом. Это называется Feature Queries (Как перевести???)

Они подобны медиа-запросам по структуре. Представьте ситуацию, где вы хотите применить цвет к элементу, если цвет это поддерживаемое свойство. (Определенно так и должно быть!). Вот фича-запрос для такой проверки:

```css
@supports (color: black) {
    body {color: black;}
    h1 {color: purple;}
    h2 {color: navy;}
}
```

Это звучит следующим образом, «Если ты можешь сделать что-то с парой color: black, то примени следующие стили, в ином случае пропусти этот блок.

Это отличный способ для прогрессивного улучшения (Progressive Enchancement) ваших стилей. Например, можно добавить поддержку grid лейаута к вашей уже созданной float и inline-block-based разметке. Можно оставить старые стили, но для современных браузеров применять уже новые.

```css
@supports (display: grid ) {
    section#main {display: grid;}
    /* styles to switch off old layout positioning */
    /* grid layout styles */
}
```

[MDN](https://developer.mozilla.org/ru/docs/Web/CSS/@supports)

При помощи `@supports` мы можем писать небольшие тесты для браузера, с целью проверить, поддерживает ли он те или иные функции (свойства или значения) и применять блок стилей (или нет) в зависимости от ответа. Например:

```css
@supports (display: grid) {
  // code that will only run if CSS Grid is supported by the browser
}
```

Этот блок будет применен к браузерам которые понимают grid и будут переопределять предыдущие стили. Браузеры не понимающие этого просто пропустят этот блок.

@supports запросы можно вкладывать в @media и наоборот

[Jen Simmons](https://hacks.mozilla.org/2016/08/using-feature-queries-in-css/) Mozilla Hacks

# Практика по сеткам

[Файлы](https://github.com/wesbos/css-grid)

## Вложенные сетки для верстки карточек альбомов

[Репозиторий](https://github.com/wesbos/css-grid)

`19 - Nesting Grid with Album Layouts`

Респонсив без медиа-запросов

## Респонсив на медиазапросах

Обзор кода

`grid-practice1`
