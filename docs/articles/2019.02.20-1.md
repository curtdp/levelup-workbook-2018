# Как работает JS?

## Основы Javascript

### Что происходит когда JavaScript выполняет (запускает) мой код?

```javascript
const num = 3;
function multiplyBy2(inputNumber) {
  const result = inputNumber * 2;
  return result;
}
const name = "Will";
```

Как только мы начинаем выполнять наш код, мы создаем _глобальный контекст выполнения_

- Поток выполнения (разбор и выполнение строка за строкой)
- Область памяти с данными (известная как Global Variable Environment)

#### Вопросы

После выполнения этого когда в каком контексте мы находимся?

### Запуск/Вызов/Выполнение функции

Это не то же самое, что определение функции

```javascript
const num = 3;
function multiplyBy2(inputNumber) {
  const result = inputNumber * 2;
  return result;
}
const output = multiplyBy2(4);
const newOutput = multiplyBy2(10);
```

Когда вы запускаете функцию вы создаете новый контекст выполнения состоящий из:

- Поток выполнения (проходим через код функции строка за строкой)
- Локальная память (Variable environment) где хранятся переменные определенные внутри функции

### Мы отслеживаем функции которые были вызываны в JS с помощью стека вызовов Call stack

Отслеживает в каком контексте выполнения мы находимся — какая функция выполняется в текущий момент и куда вернуться после того как контекст выполнения "вылетит" (popped off) из стека

Один глобальный контекст, новый контекст выполнения для каждого запуска функции

## Асинхронный JavaScript (колбеки, промисы)

### Асинхронность это фундамент современной веб разработки на JavaScript

JavaScript однопоточен (одна команда выполняется за один раз) и имеет синхронную модель выполнения (каждая команда выполняется в порядке появления сверху вниз)

Но что если нам нужно **подождать некоторое время прежде чем мы сможем выполнить некоторые куски кода**? Например нам нужно дождаться завершения получения свежих данных из API/запроса на сервере, таймера и затем выполнять наш кода.

У нас есть дилема — напряжение между желанием **отложить выполнение некоторого кода, но не блокировать поток выполнения** для других задач, пока мы ожидаем

### Решение 1

```javascript
function display(data){
    console.log(data)
}
const dataFromAPI = fetchAndWait('https://twitter.com/will/tweets/1')
//... Ни чего нельзя запустить тут!
//... может занимать 300ms, пол секунды
 // мы кликаем но ни какой реакции
display(dataFromAPI)
console.log(“Me later!”);
```

#### Проблемы

- Фундаментально не приемлемо — блокируем наш единственный поток выполнения от запуска любого другого кода пока не завершится задача

#### Преимущества

- Лего воспринимать и судить о таком коде

### Цели

1. Возможность выполнять длительные задачи (получение данных с сервера)
2. Продолжать выполнять наш JavaScript код строка з астрокой без длительной блокировки
3. Когда наша медленная задача закончилась, мы должны иметь возможность запустить функциональность зная что задача завершена и данные готовы к использованию!

Дилема

### Решение 2 — Представляем API браузера/Фоновые потоки Node

```javascript
function printHello(){
    console.log(“Hello”);
}
setTimeout(printHello,1000);
console.log(“Me first!”);
```

### Мы взаимодействуем с миром снаружи JavaScript — нам нужны правила

```javascript
function printHello(){
    console.log(“Hello”);
}
function blockFor1Sec(){
    // блокирует выполнение на 1 секунду
}
setTimeout(printHello,0);
blockFor1Sec()
console.log(“Me first!”);
```

### Проблемы

- Нет проблем!
- Данные ответа будут доступны только внутри колбека — Callback Hell
- Возможно не привычно думать про передачу функций внутрь других фукнций только для того чтобы запустить их когда-то позже

### Преимущества

- Очень четкая система, когда вы поймете как это работает под капотом

### Практика

[http://csbin.io/promises](http://csbin.io/promises)

## Promises

- Специальные объекты добавленные в JavaScript которые немедленно возвращаются когда мы обращаемся к функциям браузера (fetch) которые могут возвращать Промисы
- Промисы ведут себя как плейсхолдер для данных которые мы надеемся получить из фоновой задачи браузера
- Мы также добавляем функциональность запуск которой мы хотим отложить до момента завершения фоновой задачи (используя встроенный метод .then)
- Объект Промиса автоматически запускает эту функциональность
  - Значение возвращенное из функции браузера (данные с сервера полученные с fetch) будут аргументом этой функциональности

### Решение 3 — используя функции 'фасады' которые инициируют фоновую задачу браузера и возвращают объект плейсхолдер (promise) немедленно в JavaScript

```javascript
function display(data){
    console.log(data)
}
const futureData = fetch('https://twitter.com/will/tweets/1')
futureData.then(display); // Attaches display functionality
console.log(“Me first!”);
```
