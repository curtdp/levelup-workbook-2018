# Set, Generator, Symbol и другие темы

## Set

Set это коллекция уникальных значений

ECMAScript 5 не имеет структуры данных как Set (набор). Есть два способа обойти это ограничение:

- Использовать ключи объекта, для хранения элементов набора строк
- Хранить (произвольный) набор элементов в массиве: Проверять уникальность элемента через `indexOf()`, удалять элементы при помощи `filter()` и т. д. Это не очень быстрое решение но простое в реализации. Единственная проблема в том, что `indexOf()` не может находить значения `NaN`.

```javascript
const arr = [5, 1, 5, 7, 7, 5];
const unique = [...new Set(arr)]; // [ 5, 1, 7 ]
```

Как вы видите, инициализировать Set можно значениями если вы передадите конструктору iterable (например массив)

Управление элементами по одному:

```javascript
const set = new Set();
set.add("red"); //?
set.has("red"); //?
set.delete("red"); //?
set.has("red"); //?
```

Определение размера Сета и его очистка:

```javascript
const set = new Set();
set.add("red"); //?
set.add("green"); //?
set.size; //?
set.clear(); //?
set.size; //?
```

[Использование Set](http://exploringjs.com/impatient-js/ch_sets.html)

### Перебор Set

```javascript
```

### FAQ по Map и Set

#### Почему Map и Set имеют свойство `size` а не `length`?

Массивы имеют свойство length для учета количества вхождений. Map и Set имеют другое свойство `size`.

Причиной для этого является то, что `length` используется для последовательностей, структур данных которые имеют числовые индексы, как массивы. `size` для коллекций которые в основном не упорядочены — как Map и Set.

#### Когда использовать Map, а когда Object?

Если вы связываете что-либо кроме строк с любым типом данных, тогда у вас не остается выбора: Map.

Если вы связываете строки с произвольными данными вам нужно решить использовать ли для этого Object. Общие рекомендации:

- Есть ли фиксированный набор ключей (известный на этапе разработки)? Тогда используйте объект и получайте значения по фиксированному ключу: `obj.key`
- Может ли набор ключей измениться на этапе выполнения? Тогда используйте Map и получайте доступ к значениям по ключам сохраненным в переменных `map.get(theKey)`

#### Когда использовать объект в качестве ключа для Map?

Ключи Map'а имеют смысл если они сравниваются по значению (Одинаковое "содержимое" означает, что два значения подразуметваются равными, но не идентичными). Это исключаeт объекты. Единственный пример использования — привязывание внешних данных к объекту. Но в этом случае лучше использовать WeakMaps где вхождения удаляются, когда исчезает ключ.

## Generators

О генераторах можно думать как о процессах (кусках кода), которые вы можете приостановить и возобновить выполнение позже.

[Генераторы](http://exploringjs.com/impatient-js/ch_sync-generators.html)

### Зачем `yield` приостанавливает выполнение?

Для чего `yield` приостанавливает выполнение? Почему он не работает как метод массивов `.push()` и не заполняет iterable значениями без паузы?

Благодаря паузам, генераторы предоставляют множество возможностей для реализации сопрограмм (coroutines) (одновременное выполнение нескольких задач). Например, когда вы просите следующее значение iterable, это значение вычисляется _лениво_ (по требованию).

## yield\* делегирование — выводить все от другого генератора или iterable

[`yield*`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*)

## Symbols

[Symbol](https://developer.mozilla.org/en-US/docs/Glossary/Symbol)

```javascript
const igor = Symbol("Igor");
const person = Symbol("Igor");

console.log(igor === person);

// const priceList = {
//   'car': {price: 50, count: 3},
//   'airplane': {price: 250, count: 1},
//   'airplane': {price: 100, count: 1},
// }

const priceList = {
  [Symbol("car")]: { price: 50, count: 3 },
  [Symbol("airplane")]: { price: 250, count: 1 },
  [Symbol("airplane")]: { price: 100, count: 1 }
};
// Символы не перечисляются
for (item in priceList) {
  console.log(item);
}

const syms = Object.getOwnPropertySymbols(priceList);
const data = syms.map(sym => priceList[sym]);
console.log(data);
```

## Чейнинг

[Чейнинг](https://schier.co/blog/2013/11/14/method-chaining-in-javascript.html)
