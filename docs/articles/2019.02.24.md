# Модули JavaScript

[GitHub](https://github.com/curtdp/ModulesDemo)

[Блогпост](https://tylermcginnis.com/javascript-modules-iifes-commonjs-esmodules/)

## Слайды

Система модулей позволяет компоновать и повторно использовать код javascript.

Чтобы лучше понять как работают модули, мы посмотрим как работали модули прошлого и какие проблемы они решают.

Но прежде чем изучать модули javascript, мы сначала должны разобраться и понять что это такое и почему они существуют.

Если осмотреться вокруг, то можно заметить, что любой более-менее сложный предмет скорее всего сделан из индивидуальных фрагментов, которые собраны вместе и формируют собственно этот предмет.

Например часы. На первый взгляд это просто часы, но они собраны из сотен отдельных частей, каждый из которых имеет специальное назначение и четкие правила взаимодействия с другими частями механизма. Собранные вместе, все эти части формируют собственно часы.

Даже не будучи часовым инженером я думаю очевидны преимущества такого подхода.

- **Повторное использование**. Посмотрите как много одинаковых частей используются повторно в этом механизме. Используя продуманные инженерные решения, создатели часов могут повторно использовать одни и те же детали в различных аспектах дизайна этого механизма. Такая возможность повторного использования элементов упрощает процесс производства и как следствие скорее всего увеличивает его прибыльность.
- **Компонуемость**. Устанавливая четкие границы для каждого индивидуального компонента они могут собрать их вместе, чтобы создать полностью функционирующие часы из этих мелких деталей.
- **Финансовый рычаг**. Подумайте о процессе производства этих часов. Компания делает не сами часы, а все эти индивидуальные компоненты из которых часы собираются. Они могут создавать эти компоненты внутри компании, также они могут аутсорсить их изготовление другим компаниям. Не имеет значения где изготавливаются детали. Важно то, что когда эти кусочки соединяются вместе, они формируют часы.
- **Изоляция**. Понимание системы в целом может быть затруднено в связи с ее размерами и сложностью. Но так как часы собраны из маленьких кусочков каждый из которых выполняет свою конкретную функцию, О каждом из них можно рассуждать, создавать/ремонтировать в изоляции (в меньшем масштабе). Такая изоляция позволяет множеству людей работать каждый над своей частью механизма, не мешая друг-другу. Также, в случае поломки, вместо замены часов целиком, вы можете заменить только ту часть что вышла из строя.
- **Организация**. Организация это побочный продукт того что каждый индивидуальный элемент имеет четкие правила взаимодействия с другими элементами. С модульностью организация появляется сама собой без особых усилий.

Мы увидели очевидные преимущества модульности в контексте обычных предметов как часы. Но что на счет написания программ?

Оказывается что это имеет такой же смысл и преимущества.

## Слайды

```javascript
// imports
import React from "react";
import { createMemoryHistory } from "history";
import Router from "./Router";

// code
class MemoryRouter extends React.Component {
  history = createMemoryHistory(this.props);
  render() {
    return (
      <Router
        history={this.history}
        children={this.props.children}
      />;
    )
  }
}

// exports
export default MemoryRouter;
```

[import](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Statements/import)

## Преимущества модульности для кода

- **Повторное использование**. Модуль максимизирует повторное использование так как делает простым импортирование модуля в другие части программы. Более того, если модуль будет полезным в совсем другой программе, из него можно создать пакет и опубликовать репозитории как NPM. И его смогут скачать все желающие. Это то как используются Vue, React, Lodash, jQuery в настоящее время. Если вам нужен какой-либо компонент, вы просто устанавливаете его из npm и используете в своем коде.
- **Компонуемость**. Потому что модули явно определяют свои импорты и экспорты их можно легко компоновать. Более того, признаком хорошей программы является возможность легкого удаления кода. Модули повышают "удаляемость" кода.
- **Финансовый рычаг**. Реестр [NPM](https://www.npmjs.com/) содержит самую крупную в мире коллекцию бесплатных модулей для повторного использования. Уже около [800 000 модулей](http://www.modulecounts.com/) если быть конкретней. Скорее всего если вам нужен конкретный пакет, он уже есть в npm.
- **Изоляция**. Понимание системы в целом может быть затруднено в связи с ее размерами и сложностью. Но так как _ваше приложение_ собрано из маленьких кусочков каждый из которых выполняет свою конкретную функцию, О каждом из них можно рассуждать, создавать/ремонтировать в изоляции (в меньшем масштабе). Такая изоляция позволяет множеству людей работать каждый над своей _приложения_, не мешая друг-другу. Также, в случае поломки, вместо замены приложения целиком, вы можете заменить только ту часть что вышла из строя.
- **Организация**. Модули предоставляют естественную точку разделения разных фрагментов программы. Также модули помогают избежать "засорения" глобальной области видимости, а также помогают избегать столкновений имен (naming collisions)

## Код

Рассмотрим как происходила эволюция модулей в JS

Начнем с написания модулей как это было 5-10 лет назад.

У нас есть приложение со списком модулей, где мы можем добавлять нового пользователя.

Первое что приходит на ум, это разделение кода по файлам.

Смотрим код

Потом переделываем на IIFE

Наблюдаем что глобальная область видимости стала чище.

### Недостатки IIFE

- Каждый файл нужно оборачивать в IIFE
- Все равно остается глобальная переменная APP и мы можем получить коллизию
- Важен порядок подключения файлов в документе.

## Слайды Как бы мы создавали стандарт модулей

- по файлам
- явные экспорты
- явные импорты

### Явные экспорты

```javascript
// users.js

var users = ["Igor", "Dima", "Petya"];

function getUsers() {
  return users;
}

module.exports.getUsers = getUsers;
```

```javascript
// users.js

var users = ["Igor", "Dima", "Petya"];

module.exports = {
  getUsers: function() {
    return users;
  },
  sortUsers: function() {
    return users.sort();
  },
  firstUser: function() {
    return users[0];
  }
};
```

### Явные импорты

```javascript
var users = require("./users");

users.getUsers(); // ["Igor", "Dima", "Petya"]
users.sortUsers(); // ["Dima", "Igor", "Petya"]
users.firstUser(); // ["Igor"]
```

### Преимущества

Мы решили все проблемы свойственные шаблону IIFE

- Мы не должны оборачивать наши файлы в IIFE
- Не нужно заботиться о порядке подключения скриптов
- Мы ни чего не показываем в глобальной области видимости, даже APP

### Недостатки

#### За

- Node — встроенная поддержка CommonJS

#### Против

- Браузеры — не поддерживают из коробки
- Синхронный — плохо для браузеров

Почему CommonJS важен для нас, мы обсуждаем, что он плох для браузеров, если мы большую часть кода пишем для браузера?

Для этого есть решение!

## Сборщики модулей (Module Bundler)

```javascript
// app.js  ---> |         |
// users.js --> | Bundler | --> bundle.js
// dom.js  ---> |         |
```

## Переделаем все на webpack

Основы настройки конфига webpack

Инициируем npm
Установим webpack webpack-cli

Создадим webpack.config.js

```javascript
entry: './dom.js',
output: {
  path: path.resolve(__dirname),
  filename: 'bundle.js'
},
mode: 'development
```

## Стандарт модулей ES6

В этом месте вы могли подумать почему JavaScript не имеет собственной системы модулей? Ведь каждый современный язык программирования имеет систему модулей.

Хорошая вещь в том что JavaScript это живой язык, он развивается.

Даже если он изначально не имел системы модулей и нам нужно было придумывать столько хаков для добавления системы модулей.

Так как это живой язык, ни чего не мешало добавить систему модулей в спецификацию JavaScript. И это то что случилось в версии ES2015, и назывются они ES Modules.

```javascript
// utils.js

// Not exported
function once(fn, context) {
  var result;
  return function() {
    if (fn) {
      result = fn.apply(context || this, arguments);
      fn = null;
    }
    return result;
  };
}

// Exported
export function first(arr) {
  return arr[0];
}

// Exported
export function last(arr) {
  return arr[arr.length - 1];
}
```

То что похоже на деструктурирование, в модулях называется named import

### Экспорт по-умолчанию

## Переделываем на ES Modules
